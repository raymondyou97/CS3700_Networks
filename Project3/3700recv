#!/usr/bin/python

import sys
import time
import datetime
import select
import json

from socket import socket, AF_INET, SOCK_DGRAM
from struct import Struct

# for logging to stdout
def log_normal(string):
    # redirect print output to stdout
    print >> sys.stdout, (datetime.datetime.now().strftime("%H:%M:%S.%f") + " " + string + "\n")
  
# for logging to stderr
def log_error(string):
    # redirect print output to stderr
    print >> sys.stderr, (datetime.datetime.now().strftime("%H:%M:%S.%f") + " " + string + "\n")

# connect to socket and setup attributes
def setup_socket():
    my_socket = socket(AF_INET, SOCK_DGRAM)
    my_socket.bind(('127.0.0.1', 0))
    my_socket.settimeout(300000)
    return my_socket

# C struct of int, char[] of length 1400, boolean, int
packet = Struct('I 1400s ? I')
sequence_packet_map = {}
# keep tracking of sequence #s
received_sequences = []
# keep track of last acknowledgement
last_ack = 0

# Set up the socket
sock = setup_socket()

# unpacks the C struct into a Python tuple
def unpack_data(data):
    parts = packet.unpack(data)
    data_spt = parts[1].split("\x00")[0]
    return (parts[0], data_spt, parts[2], parts[3])

def send_ack_msg(sequence, data):
    my_dict = {"ack": sequence + len(data)}
    msg = json.dumps(my_dict)
    log_normal("[sending] " + msg)
    if sock.sendto(msg, addr) < len(msg):
        log_error("[error] unable to fully send packet")
    else:   
        log_normal("[success] fully send packet " + str(sequence + len(data))) 

def process_data(packet):
    global last_ack
  
    sequence, data, end_of_file_flag, _ = packet
  
    if end_of_file_flag:
        log_normal("[completed, EOF reached]")
        log_normal("[final received data] " + str(sequence_packet_map))
        sys.exit(0)

    if sequence in received_sequences:
        send_ack_msg(sequence, data)
        return

    received_sequences.append(sequence)

    # If there is data and sequence = last acked, we accept it and print it out
    # else we put it in the buffer

    if data:
        log_normal("[recv data] " + str(sequence) + " (" + str(len(data)) + ")")
        # print if the correct next order packet has arrived
        sequence_packet_map[sequence] = packet 
        next_seq = sequence
 
    while sequence_packet_map.get(next_seq, None) and last_ack == next_seq:
        to_write = sequence_packet_map.get(next_seq)
        last_ack = last_ack + len(to_write[1])
        sys.stdout.write(to_write[1])
        next_seq = next_seq + len(to_write[1])

    # Send back an ack to the sender
    send_ack_msg(sequence, data)

# Get port we bound to
udp_port = sock.getsockname()[1]
log_normal("[bound] " + str(udp_port))

# main loop where the 'receiving logic' happens
while True:
    result = sock.recvfrom(1500)
    # If nothing is ready, we hit the timeout
    if result:
        (data, addr) = result
        try:
            data_pts = unpack_data(data)
            process_data(data_pts)
        except (ValueError, KeyError, TypeError) as exc:
            log_error("[recv corrupt packet]")
            raise exc
    else:
        log_error("[error] timeout")
        sys.exit(-1)
#!/usr/bin/python

import sys
import time
import datetime
import select
import json

from socket import socket, AF_INET, SOCK_DGRAM
from struct import Struct

# for logging to stdout
def log_normal(string):
    # redirect print output to stdout
    # this should be sys.stdout but dunno why its not working. fk it for now
    print >> sys.stderr, (datetime.datetime.now().strftime("%H:%M:%S.%f") + " " + string + "\n")
  
# for logging to stderr
def log_error(string):
    # redirect print output to stderr
    print >> sys.stderr, (datetime.datetime.now().strftime("%H:%M:%S.%f") + " " + string + "\n")

# connect to socket and setup attributes
def setup_socket():
    my_socket = socket(AF_INET, SOCK_DGRAM)
    my_socket.bind(('127.0.0.1', 0))
    my_socket.settimeout(300000)
    return my_socket

# struct of int, char[] of length 1400, boolean, int
packet = Struct('I 1400s ? I')
# mapping of packet sequences
sequence_packet_map = {}
# list of sequences
received_sequences = []
# last ack or rather the ack we expect back from sender
last_ack = 0

# Set up the socket
sock = setup_socket()

# Get port we bound to
udp_port = sock.getsockname()[1]
log_normal("[bound] " + str(udp_port))

# deconstruct the C struct received
def unpack_data(data):
    parts = packet.unpack(data)
    data_spt = parts[1].split("\x00")[0]
    return (parts[0], data_spt, parts[2], parts[3])

# send back an ack to the sender
def send_ack_msg(sequence, data):
    my_dict = {"ack": sequence + len(data)}
    msg = json.dumps(my_dict)
    log_normal("[sending] " + msg)
    if sock.sendto(msg, addr) < len(msg):
        log_error("[error] unable to fully send packet")
    else:   
        log_normal("[sent] " + str(sequence + len(data))) 

def process_data(packet):
    global last_ack # to allow mutation in a local context
  
    sequence, data, end_of_file_flag, _ = packet
  
    # done if EOF found
    if end_of_file_flag:
        log_normal("[completed]")
        sys.exit(0)

    # we have the given sequence, send back an ack
    if sequence in received_sequences:
        send_ack_msg(sequence, data)
        return

    # add the new sequence to our list of received sequences
    received_sequences.append(sequence)

    if data:
        msg = "[recv data] {} ({})".format(str(sequence), str(len(data)))
        log_normal(msg)
        sequence_packet_map[sequence] = packet 
        next_sequence = sequence
    
    while sequence_packet_map.get(next_sequence, None) and last_ack == next_sequence:
        to_write = sequence_packet_map.get(next_sequence)
        last_ack = last_ack + len(to_write[1])
        sys.stdout.write(to_write[1])
        next_sequence = next_sequence + len(to_write[1])

    send_ack_msg(sequence, data)

# main loop where the 'receiving' happens
while True:
    result = sock.recvfrom(1500)
    # If nothing is ready, we hit the timeout
    if result:
        (data, addr) = result
        try:
            data_pts = unpack_data(data)
            process_data(data_pts)
        except (ValueError, KeyError, TypeError) as exc:
            log_error("[recv corrupt packet]")
            raise exc
    else:
        log_error("[error] timeout")
        sys.exit(-1)
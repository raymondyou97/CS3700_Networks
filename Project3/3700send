#!/usr/bin/python

import json
import sys
from datetime import datetime
from socket import socket, AF_INET, SOCK_DGRAM
from struct import Struct

# for logging to stdout
def log_normal(string):
    # redirect print output to stdout
    # this should be sys.stdout but dunno why its not working. fk it for now
    print >> sys.stderr, (datetime.now().strftime("%H:%M:%S.%f") + " " + string + "\n")

# for logging to stderr
def log_error(string):
    # redirect print output to stderr
    print >> sys.stderr, (datetime.now().strftime("%H:%M:%S.%f") + " " + string + "\n")

sequence_num = 0
window_size = 100
packet_data = None
sequence_packet_map = {}
acks_sent = []
packet_struct = Struct('I 1400s ? I')

ip_port = sys.argv[1]
udp_ip = ip_port[0:ip_port.find(":")]
udp_port = int(ip_port[ip_port.find(":")+1:])
dest = (udp_ip, udp_port)

# connect to socket and setup attributes
def setup_socket():
    my_socket = socket(AF_INET, SOCK_DGRAM)
    my_socket.settimeout(1.2)
    return my_socket

# Set up the socket
sock = setup_socket()

# Retrieve data from STDIN
def read_stdin():
    final_data = ""
    while True:
        intake = sys.stdin.read(1400)
        if len(intake) > 1:
            final_data += intake
        else:
            return final_data

def send_next_packet():
    global sequence_num
    global packet_data
    global window_size
    global sequence_packet_map
    global packet_struct

    for i in range(window_size):
        data = packet_data[:1400]

        if len(data) < 1:
            return i != 0
        else:
            packet_data = packet_data[1400:]
            packet = packet_struct.pack(sequence_num, data, False, window_size)
            assert (len(packet) <= 1472), "ERROR: Datagram is longer than 1472 bytes!!!"

            sequence_num += len(data)
            if sock.sendto(packet, dest) < len(packet):
                log_error("[error] unable to fully send packet")
            else:
                sequence_packet_map[sequence_num] = (packet, len(data))
                log_normal("[send data] " + str(sequence_num) + " (" + str(len(data)) + ")")
    return True

def resend_packet(seq):
    global sequence_packet_map
    (to_resend, size) = sequence_packet_map[seq]
    if sock.sendto(to_resend, dest) < len(to_resend):
        log_error("[error] unable to fully send packet")
    else:
        log_normal("[send data] " + str(seq) + " (" + str(size) + ")")

packet_data = read_stdin()

# Send first packet
send_next_packet()

# Now read in data, send packets
while True:
    expected_acks = []
    seq = sequence_num

    for i in range(window_size):
        if seq not in expected_acks and seq not in acks_sent:
            expected_acks.append(seq)
        packet = sequence_packet_map.get(seq)
        prev_packet = sequence_packet_map.get(seq - packet[1], None)
        if not prev_packet:
            break
        seq = seq - packet[1]

    log_normal(str(expected_acks))

    while True:
        if len(expected_acks) == 0:
            break

        result = None
        try:
            result = sock.recvfrom(1500)
        except:
            if len(expected_acks) > (window_size / 2):
                log_error("uhoh")
            for seq in expected_acks:
                resend_packet(seq)
            continue

        if result:
            (data, addr) = result
            try:
                decoded = json.loads(data)
                ack = decoded['ack']

                if ack in expected_acks:
                    acks_sent.append(ack)
                    expected_acks.remove(ack)
                    log_normal("[recv ack] " + str(ack))

            except (ValueError, KeyError, TypeError):
                log_error("[recv corrupt packet]")
        else:
            log_error("[error] timeout")
            sys.exit(-1)

    window_size = window_size * 2
    # Try to send next packet; break if no more data
    if (not send_next_packet()):
        break

for i in range(10):
    fin = packet_struct.pack(sequence_num, "", True, window_size)
    sock.sendto(fin, dest)

sys.exit(0)